<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单片机51</title>
    <url>/2023/03/23/%E5%8D%95%E7%89%87%E6%9C%BA51/</url>
    <content><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>硬件: 单片机：STC89C52RC,<br>软件: 开发环境-keil-5,烧录软体-stc-isp,驱动</p>
<hr>
<h2 id="术语，电路相关，c语言相关库"><a href="#术语，电路相关，c语言相关库" class="headerlink" title="术语，电路相关，c语言相关库"></a>术语，电路相关，c语言相关库</h2><p>寄存器；就是0/1，一般8个bit为一个寄存器。高电平（1），低电平（0）。<br>vcc：正极输入，也就是高电平。<br>晶振：计时要根据cpu的晶振计算，可在烧录软件生成相应的函数，要指定频率，时长，还有板子的指令集适用<br>nop函数：#include &lt;INTRINS.H&gt; 插入头文件nop，汇编指令集的空操作，用于延时功能<br>单边机: 根据硬件制造商的约定，库定义各个引脚的名称，根据这些名称实现高低电平的转换。</p>
<h2 id="相关图片"><a href="#相关图片" class="headerlink" title="相关图片"></a>相关图片</h2><h5 id="在开发环境中选中你的cpu型号"><a href="#在开发环境中选中你的cpu型号" class="headerlink" title="在开发环境中选中你的cpu型号"></a>在开发环境中选中你的cpu型号</h5><img src=/images/51singlechip01.png width="100%" alt="测试图片"/>

<h5 id="引入cpu定义的库"><a href="#引入cpu定义的库" class="headerlink" title="引入cpu定义的库"></a>引入cpu定义的库</h5><img src=/images/51singlechip03.png width="100%" alt="测试图片" >
<img src=/images/51singlechip02.png width="100%" alt="测试图片" >


<h5 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h5><p>在烧录页面可获取时间函数，会根据晶振来计算，若自己实现参数传递，感觉不了解相关算法单纯循环1s会多几次晶振导致不准确，循环次数越多越不准，单次时间越长越准，可以考虑什么时候可以忽略。<br><img src=/images/51singlechip.png width="100%" alt="测试图片" ></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 51单片机,流水灯</span><br><span class="line"><span class="comment">#include &lt;REGX52.H&gt;</span></span><br><span class="line"><span class="comment">#include &lt;INTRINS.H&gt;</span></span><br><span class="line">void Delay500ms()		//@11.0592MHz</span><br><span class="line">&#123;</span><br><span class="line">	unsigned char i, j, k;</span><br><span class="line"></span><br><span class="line">	_nop_();</span><br><span class="line">	i = 4;</span><br><span class="line">	j = 129;</span><br><span class="line">	k = 119;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (--k);</span><br><span class="line">		&#125; <span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	int n=1;</span><br><span class="line">	<span class="keyword">while</span>(1)&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==8)&#123;</span><br><span class="line">		n=0;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		P2=~(1&lt;&lt;<span class="string">n);</span></span><br><span class="line"><span class="string">		n</span>++;</span><br><span class="line">		Delay500ms();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>java_IO源码思考</title>
    <url>/2023/03/19/java-IO%E6%BA%90%E7%A0%81%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="file类实例化"><a href="#file类实例化" class="headerlink" title="file类实例化"></a>file类实例化</h2><p>文件名乱写，并不报错，说明这只是一个java抽象并没和操作系统交互,与文件没有实际联系，只有理论上路径联系。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">File file = new File(<span class="string">&quot;./...asd.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="FileInputStream类实例化"><a href="#FileInputStream类实例化" class="headerlink" title="FileInputStream类实例化"></a>FileInputStream类实例化</h2><p>有io异常，说明有交互，调取了操作系统的api。<br>java.io.FileNotFoundException: .\src (拒绝访问。)<br>    at java.base/java.io.FileInputStream.open0(Native Method)<br>    private native void open0(String name) throws FileNotFoundException;<br>    at java.base/java.io.FileInputStream.open(FileInputStream.java:219)<br>    at java.base/java.io.FileInputStream.<init>(FileInputStream.java:157)<br>    at java.base/java.io.FileInputStream.<init>(FileInputStream.java:112)<br>    at Solution.main(Solution.java:62)<br> java最底层的方法是private native void open0(String name) throws FileNotFoundException;<br> 可以看出给操作系统传了一个参数文件路径，无返回值，有异常。<br> 这证明所谓的流就是查看文件是否存在，存在就可以交互，不存在就抛出异常，然后在有java的一些抽象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream = new FileInputStream(<span class="string">&quot;./src/&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="FileInputStream-getChannel-源码"><a href="#FileInputStream-getChannel-源码" class="headerlink" title="FileInputStream.getChannel()源码"></a>FileInputStream.getChannel()源码</h2><p>对于一个inputstream流来说只有同一个channel，所以加锁，实现方法类似单例模式，具体由FileChannelImpl.open()实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public FileChannel <span class="function"><span class="title">getChannel</span></span>() &#123;</span><br><span class="line">        FileChannel <span class="built_in">fc</span> = this.channel;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fc</span> == null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                <span class="built_in">fc</span> = this.channel;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fc</span> == null) &#123;</span><br><span class="line">                    this.channel = <span class="built_in">fc</span> = FileChannelImpl.open(fd, path, <span class="literal">true</span>,</span><br><span class="line">                        <span class="literal">false</span>, <span class="literal">false</span>, this);</span><br><span class="line">                    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            // possible race with close(), benign since</span><br><span class="line">                            // FileChannel.close is final and idempotent</span><br><span class="line">                            fc.close();</span><br><span class="line">                        &#125; catch (IOException ioe) &#123;</span><br><span class="line">                            throw new InternalError(ioe); // should not happen</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">fc</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="FileChannelImpl-open-源码"><a href="#FileChannelImpl-open-源码" class="headerlink" title="FileChannelImpl.open()源码"></a>FileChannelImpl.open()源码</h2><p>直接返回的是FileChannelImpl的实例，就是新造了一个FileChannelImpl下面是它的构造函数。<br>重点是 this.alignment = nd.setDirectIO(fd, path)，它的实现方法是native方法，给操作系统传入了两个参数FileDescriptor fd, CharBuffer buffer,返回值是int即下面的this.alignment。<br>其中buffer中存放着path去掉文件名后的char(ASCII码)。感觉作用就是一个约定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private FileChannelImpl(FileDescriptor fd, String path, boolean readable,</span><br><span class="line">                         boolean writable, boolean direct, Object parent)</span><br><span class="line"> &#123;</span><br><span class="line">     this.fd = fd;</span><br><span class="line">     this.readable = readable;</span><br><span class="line">     this.writable = writable;</span><br><span class="line">     this.parent = parent;</span><br><span class="line">     this.path = path;</span><br><span class="line">     this.direct = direct;</span><br><span class="line">     this.nd = new FileDispatcherImpl();</span><br><span class="line">     <span class="keyword">if</span> (direct) &#123;</span><br><span class="line">         assert path != null;</span><br><span class="line">         this.alignment = nd.setDirectIO(fd, path);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         this.alignment = -1;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="native本地方法"><a href="#native本地方法" class="headerlink" title="native本地方法"></a><a href="https://ask.csdn.net/questions/7905174/54122660">native本地方法</a></h2><p>大佬的回答，暂时还不是很能理解，这里是已经在内存上创建了内存映射区了，还是说只是做好了约定。<br>传入的是文件描述符（也就相当于打开文件的句柄，以及缓冲区指针）<br>返回的是每扇区字节数（如果出错返回-1）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line">Java_sun_nio_ch_FileDispatcherImpl_setDirect0(JNIEnv *env, jclass this,</span><br><span class="line">                                              jobject fdObj, jobject buffer)</span><br><span class="line">&#123;</span><br><span class="line">    jint result = -1;</span><br><span class="line"> </span><br><span class="line">    HANDLE orig = (HANDLE)(handleval(env, fdObj));</span><br><span class="line"> </span><br><span class="line">    HANDLE modify = ReOpenFile(orig, 0, 0,</span><br><span class="line">            FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (modify != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        DWORD sectorsPerCluster;</span><br><span class="line">        DWORD bytesPerSector;</span><br><span class="line">        DWORD numberOfFreeClusters;</span><br><span class="line">        DWORD totalNumberOfClusters;</span><br><span class="line">        LPCWSTR lpRootPathName = (*env)-&gt;GetDirectBufferAddress(env, buffer);</span><br><span class="line">        BOOL res = GetDiskFreeSpaceW(lpRootPathName,</span><br><span class="line">                                     &amp;sectorsPerCluster,</span><br><span class="line">                                     &amp;bytesPerSector,</span><br><span class="line">                                     &amp;numberOfFreeClusters,</span><br><span class="line">                                     &amp;totalNumberOfClusters);</span><br><span class="line">        <span class="keyword">if</span> (res == 0) &#123;</span><br><span class="line">            JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;DirectIO setup failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = bytesPerSector;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2023/03/18/IO%E6%B5%81/</url>
    <content><![CDATA[<p>个人思考：<br>目前我知道的是软件只能操作自己的内存空间不能操作其他的内存空间（因为不知道内存地址）?操作系统，和java程序这些都属于一个软件。那么io操作就应该是由硬件配套的程序管理的（驱动程序吗？）。当操作系统需要读取文件时，不应该是操作系统去写入而是操作系统向驱动程序发起读取请求，然后把自己的内存空间暴露给驱动系统，驱动系统再向其中写入文件?而java的老版本是：先驱动把文件写进操作系统的内存空间，操作系统再写入java暴露给操作系统的java内存空间，两次copy效率低，现在是建立映射，而操作系统暴露给驱动的内存空间实际上是java暴露给操作系统的内存空间吗？我的理解对吗，所以内存映射并不是java层实现的对吗，而是操作系统层实现的吗？而且如果是硬盘上的拷贝，各个软件传递的也是最终文件放置空间的地址值而非真正的拷贝? 求指导，我是一个非科班的初学者，希望得到的帮助 ，最好能详细讲解从硬件数据到java内存的过程包括各种协议的名称，作用，具体的实现细节可以不用告知，我想知道一个正确的框架?还有个问题，如果是我说的这样，为什么java不去直接找驱动，是不知道驱动的路径吗，只有安装了驱动的操作系统才有交互的可能？而安装的驱动实际上有点像嵌入式开发的软体？</p>
]]></content>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2023/03/18/maven/</url>
    <content><![CDATA[<p>sb-MAVEN<br>一点依赖传递都没解决，存粹的一个jar包管理工具，单纯只想引进个日志slf4j就搞我半天草</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.7.30&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>javaSocket</title>
    <url>/2023/03/18/javaSocket/</url>
    <content><![CDATA[<p>背景:<br>同一个手机，连接java监听的端口.<br>刚开始连接时,java生成一个socket，当socket没关闭时，这个手机再发送一个请求会被阻塞。</p>
]]></content>
  </entry>
  <entry>
    <title>html_CSS</title>
    <url>/2023/03/13/html-CSS/</url>
    <content><![CDATA[<p>div内文字：<br>a. 字母时，空格区别一个单词，换行时不会切割单词。<br>b. 汉字时，自动换行。<br>把div当作蒙板时，可以遮住iframe，遮不住select。可以使用iframe可以遮盖select，一般使用iframe和div结合的办法遮盖select（div所以要比iframe的z索引高）并创建内容，其实iframe会自动隐藏select，也可以自己只使用div和js隐藏select。如本博客主页所遇到的,下面的div用来在移动端时，遮住音乐播放器，和主页select视频，放弃hover事件模拟播放器iframe的点击事件。<br></p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;musicMobileCover&quot;</span>&gt;</span><br><span class="line">      &lt;iframe hidden&gt;</span><br><span class="line">      &lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>a标签herf失效时直接绑定点击事件<br>a标签的download只有只在该路径下的文件时才会自动下载</p>
<p>有关位置定位的属性整理<br>position<br>margin<br>float<br>display<br>padding</p>
]]></content>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>lanIP</title>
    <url>/2023/03/13/lanIP/</url>
    <content><![CDATA[<h1 id="路由寻址的摸索"><a href="#路由寻址的摸索" class="headerlink" title="路由寻址的摸索"></a>路由寻址的摸索</h1><p>个人理解，ip对应网卡，实际是多个虚拟网卡。mac对应主机，实际是对应端口号。<br>自己下午测了一下路由的各种情况，画了个表，大概知道路由器会有路由表，寻址时先广播找MAC。<br></p>
<span id="more"></span>
<img src=/images/post_lanip01.png width="100%" alt="测试图片" >
4.在同一个wifi下（应该是同频率下），192.168.8.5（包装自己的Mac）在广播寻址192.168.8.2，在相同频段内连接的所有的网卡均能收到8.5寻找8.2信息，只要自身是8.2就可以回复并发送自己的Mac，不是8.2的不回复（存在多个冲突，推测先到先得），8.5在根据目标8.2的mac发送报文。（本次的路由器ip为192.169.0.1/24，与子网不同，推测路由器并不会在路由表中维护8.5的ipmac关系或者说路由器根本收不到广播？如果路由器ip192.168.8.1/24等包含8.5ip，则会维护）。


]]></content>
      <tags>
        <tag>ip</tag>
        <tag>bug</tag>
        <tag>局域网</tag>
        <tag>DHCP</tag>
        <tag>路由器</tag>
        <tag>路由表</tag>
      </tags>
  </entry>
  <entry>
    <title>pansansuiBlog</title>
    <url>/2023/03/09/pansansuiBlog/</url>
    <content><![CDATA[<h1 id="本博客的框架和结构（Hexo框架，Ocean主题）"><a href="#本博客的框架和结构（Hexo框架，Ocean主题）" class="headerlink" title="本博客的框架和结构（Hexo框架，Ocean主题）"></a>本博客的框架和结构（Hexo框架，Ocean主题）</h1><p>完全自己一个人摸索的，理解不一定正确<br></p>
<span id="more"></span>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><blockquote>
<p>node_modules—————————-npm下载的各种依赖插件，hexo服务器，各类hexo的插件<br>public———————————-hexo给你的工程编译后的工程结构，实际上你开发的项目部署时的结构<br>scaffolds—————————-模板，hexo new 可以按照里面的模板来生产Markdown</p>
<blockquote>
<p>draft —————————-blog的草稿文件模板he<br>post—————————-发布的blog模板<br>page—————————-页面模板!!!区分blog和页面，</p>
</blockquote>
<p>source—————————-对应scaffolds模板创建出来的文件，写博文主要在这个文件下面编辑</p>
<blockquote>
<p>_draft<br>_posts<br>about<br>gallery<br>link<br>video</p>
</blockquote>
<p>themes—————————-主题</p>
<blockquote>
<p>ocean</p>
<blockquote>
<p>languages<br>layout</p>
<blockquote>
<p>layout.ejs—————————- 每个页面的入口文件<br>_config.yml —————————-ocean主题的配置文件</p>
</blockquote>
</blockquote>
</blockquote>
<p>_config.landscape.yml<br>_config.yml hexo的配置文件</p>
</blockquote>
<p>工程的流程，hexo是帮助我们生成静态网站结构的脚手架。<br>我们编写的代码会被hexo g生成一定结构的静态网站，具体的结构为public文件下的结构。<br>所以js文件有两种：<br>a:一种是为hexo制订规则，各类hexo插件<br>b:一种是为网站写js代码，供游览器执行</p>
<hr>
<p>a的情况下：当为hexo制订规则时，文件应该是themes/ocean(你的主题)/scripts/文件夹下写js代码，没有就自建，hexo本身也声明了一些函数api供我们调用，具体可取官网查看。目前用到的有<br>hexo.extend.generator.register这是你写的文件到时候生成到pubic的什么路径，就是文件的映射。<br>hexo.extend.injector.register这是注入函数，即hexo会按照规则生成html页面，我们可以修改这个规则，如在body页面注入你想要的效果。<br>hexo.extend.tag.register这是注册一个用于markdown文件中的语法规则，hexo会按照你的规则解析markdowon文件。<br>b的情况下：为html写的js代码，供游览器执行,我的目录是在themes/ocean(你的主题)/source/js/<br>hexo编译静态文件的入口是themes/ocean(你的主题)/layout/layout.ejs</p>
<hr>
<h2 id="Done-and-todoList"><a href="#Done-and-todoList" class="headerlink" title="Done and todoList"></a>Done and todoList</h2><p><del>制作博客各种图标</del><br><del>引入网易云音乐</del><br><del>网易云音乐控件动画</del><br><del>网易云音乐控件动画抽搐bug</del><br><del>网易云音乐移动和pc端的适配</del><br>网易云音乐全站唯一对象（感觉不行，网址不能跳，只能把其他所有界面放到iframe里，iframe里没有服务器很难实现其他功能，把js弄到游览器上跑？）<br><del>引入b站视频</del><br><del>实现b站同款视频卡片页</del><br><del>解决b站防盗链（无语了开放api得到的数据加防盗链是咋想的）</del><br><del>修复b站卡片无法跳转的问题</del><br>判断游览器是否支持默认播放，否则关闭play()<br><del>实现read more</del><br><del>实现相册</del><br><del>实现下载功能</del><br><del>欠3道算法题</del><br><del>欠1道算法题</del><br>实现连接里面的分享卡片，写个hexo插件<br>实现图片的放大查看fancybox<br>完成博文lanIP<br>完成Hexo-SEO-AutoPush，方便搜索引擎爬取<br>实现夜间模式<br>html-CSS博文待完善</p>
]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>ocean</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2023/03/09/mysql/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoOceanSkill</title>
    <url>/2023/03/08/hexoOceanSkill/</url>
    <content><![CDATA[<p>ocean 主题的feathericon的代号映射位置在themes\ocean\source\css_feathericon.styl下<br>ocean 主题的菜单更改图标的文件在themes\ocean\source\css_partial\navbar.styl中</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题:"></a>遇到的问题:</h1><p>制作谷歌播放器动画的时候，声明在themes\ocean\source\css_partial\layout.styl 的属性绑定不了上iframe，最后在themes\ocean\source\js\ocean.js中用jQuery绑定的，原因初步<del>推测是要等iframe渲染好才可以绑定style属性。</del><br>—发现部署在github上的和自己hexo server运行的不一样，且导航栏的颜色属性也莫名奇妙的被覆盖了，现在怀疑是hexo g的时候哪里覆盖了layout.styl的属性或者根本没用上。<br>—真搞不懂了，在layout.styl删除了@media (min-width: 768px)下面的sidebar所有属性后，github上的导航栏恢复正常了，注释掉ocean.js的播放器动画，声明在layout.styl上也行了，问题是sidebar的颜色前后声明都是一样的为啥后面不行。<br></p>
<span id="more"></span>
<p>–受不了啦，明明写的right为-10rem喵的hexo g编译老是给爷改成10rem，最后2023手动改了public里的ocean.js和styl.styl，to do ：实现手机端的播放器透明，不透明转换，顶端粘粘。<br>–搞明白了，没有hexo clean之前残留的文件冲突了，无语了还以为会和git一样版本控制就没有每次clean，心塞。</p>
]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2023/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="每天一道算法题"><a href="#每天一道算法题" class="headerlink" title="每天一道算法题"></a>每天一道算法题</h1><p>date: 2023-3-10 8:00</p>
<h2 id="题目一：字符串转换整数"><a href="#题目一：字符串转换整数" class="headerlink" title="题目一：字符串转换整数"></a>题目一：<a href="https://leetcode.cn/problems/string-to-integer-atoi/">字符串转换整数</a></h2><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）<br></p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">        /*</span><br><span class="line">    * @Description:有限状态自动机</span><br><span class="line">    * @ParamType:null</span><br><span class="line">    * @Param: null</span><br><span class="line">    * @<span class="built_in">return</span>: null </span><br><span class="line">    * @Author: panpan</span><br><span class="line">    * @Date:10/3/2023</span><br><span class="line">    */</span><br><span class="line">    public int myAtoi(String s) &#123;</span><br><span class="line">        autoMachine autoMachine = new autoMachine();</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">            autoMachine.changeState(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        <span class="keyword">if</span>(autoMachine.state==2||autoMachine.state==3)&#123;</span><br><span class="line">            <span class="keyword">if</span>(autoMachine.sign)&#123;</span><br><span class="line">                res=(int) autoMachine.val;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res=-(int) autoMachine.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    * @Description:</span><br><span class="line">    * @ParamType:null</span><br><span class="line">    * @Param: null</span><br><span class="line">    * @<span class="built_in">return</span>: null </span><br><span class="line">    * @Author: panpan</span><br><span class="line">    * @Date:10/3/2023</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">   class autoMachine&#123;</span><br><span class="line">        private Integer state=0;</span><br><span class="line">        private HashMap&lt;Integer,Integer[]&gt; stateChangeTable=new HashMap&lt;Integer, Integer[]&gt;()&#123;</span><br><span class="line">            //    state       &#123;<span class="string">&#x27;&#x27;</span>,+/-,num,other&#125;</span><br><span class="line">            &#123; put(0, new Integer[]&#123;0,1,2,3&#125;);</span><br><span class="line">              put(1,new Integer[]&#123;3,3,2,3&#125;);</span><br><span class="line">              put(2, new Integer[]&#123;3,3,2,3&#125;);</span><br><span class="line">              put(3,new Integer[]&#123;3,3,3,3&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 正负</span><br><span class="line">       private boolean sign=<span class="literal">true</span>;</span><br><span class="line">       // 值</span><br><span class="line">       private long val=0l;</span><br><span class="line">       private void changeState(char c)&#123;</span><br><span class="line">            // 改变状态</span><br><span class="line">            state = stateChangeTable.get(state)[nextState(c)];</span><br><span class="line">            // 判断当前状态是数字</span><br><span class="line">            <span class="keyword">if</span>(state==2)&#123;</span><br><span class="line">                // 减去ascii码的0起始位</span><br><span class="line">                val=val*10+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                // 最大的绝对值不一样,踩坑min_value的绝对值还是min—value负数，因为比max大，二进制就是最小值。</span><br><span class="line">                val=sign?Math.min(Integer.MAX_VALUE, val):Math.min(-(long) Integer.MIN_VALUE, val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state==1)&#123;</span><br><span class="line">                sign=<span class="string">&#x27;+&#x27;</span>==c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        private int nextState(char c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&#x27; &#x27;</span>==c)&#123;</span><br><span class="line">                <span class="built_in">return</span> 0;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;+&#x27;</span>==c||<span class="string">&#x27;-&#x27;</span>==c)&#123;</span><br><span class="line">                  <span class="built_in">return</span> 1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c))&#123;</span><br><span class="line">                <span class="built_in">return</span> 2;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">return</span> 3;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二：比较版本号"><a href="#题目二：比较版本号" class="headerlink" title="题目二：比较版本号"></a>题目二：<a href="https://leetcode.cn/problems/compare-version-numbers/">比较版本号</a></h2><p>给你两个版本号 version1 和 version2 ，请你比较它们。<br>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    * @Description:笨蛋双指针和递归..</span><br><span class="line">    * @ParamType:string</span><br><span class="line">    * @Param: null</span><br><span class="line">    * @<span class="built_in">return</span>: int</span><br><span class="line">    * @Author: panpan</span><br><span class="line">    * @Date:14/3/2023</span><br><span class="line">    */</span><br><span class="line">public  static int compareVersion(String rev1, String rev2) &#123;</span><br><span class="line">        int start1=-1,start2=-1,end1=-1,end2=-1;</span><br><span class="line">        // 找rev1 的起始位置</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; rev1.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rev1.charAt(j)&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;rev1.charAt(j)&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                start1=j;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rev1.charAt(j)&lt;<span class="string">&#x27;0&#x27;</span>||rev1.charAt(j)&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rev1.charAt(j)!=<span class="string">&#x27;.&#x27;</span>)&#123;<span class="built_in">return</span> 0;&#125;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //rev结束位置</span><br><span class="line">        <span class="keyword">for</span> (int j = start1==-1?0:start1; j &lt; rev1.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rev1.charAt(j)==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                end1=j;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rev1.charAt(j)&lt;<span class="string">&#x27;0&#x27;</span>||rev1.charAt(j)&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">return</span> 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 找rev2 的起始位置</span><br><span class="line">        <span class="keyword">for</span> (int j = 0; j &lt; rev2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rev2.charAt(j)&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;rev2.charAt(j)&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                start2=j;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rev2.charAt(j)&lt;<span class="string">&#x27;0&#x27;</span>||rev2.charAt(j)&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rev2.charAt(j)!=<span class="string">&#x27;.&#x27;</span>)&#123;<span class="built_in">return</span> 0;&#125;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //rev2结束位置</span><br><span class="line">        <span class="keyword">for</span> (int j = start2==-1?0:start2; j &lt; rev2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(rev2.charAt(j)==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                end2=j;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rev2.charAt(j)&lt;<span class="string">&#x27;0&#x27;</span>||rev2.charAt(j)&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">return</span> 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //判断是否全是0,或者没有.或者空串</span><br><span class="line">        //判断revision修订号</span><br><span class="line">        int i1 = start1==-1?0:Integer.parseInt(rev1.substring(start1, end1==-1?rev1.length():end1));</span><br><span class="line">        int i2 = start2==-1?0:Integer.parseInt(rev2.substring(start2, end2==-1?rev2.length():end2));</span><br><span class="line">        <span class="keyword">if</span>(i1&gt;i2)&#123;</span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i1&lt;i2)&#123;</span><br><span class="line">            <span class="built_in">return</span> -1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            //递归</span><br><span class="line">            <span class="keyword">if</span>((end1==-1&amp;&amp;end2==-1)||(end1+1==rev1.length()&amp;&amp;end2+1==rev2.length()))&#123;</span><br><span class="line">                <span class="built_in">return</span> 0;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(end1==-1)&#123;</span><br><span class="line">               <span class="built_in">return</span> compareVersion(<span class="string">&quot;0&quot;</span>, rev2.substring(end2+1));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(end2==-1)&#123;</span><br><span class="line">                <span class="built_in">return</span> compareVersion(rev1.substring(end1+1), <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">return</span> compareVersion(rev1.substring(end1+1), rev2.substring(end2+1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//数字直接算就好，官方答案</span><br><span class="line">    public int compareVersion(String version1, String version2) &#123;</span><br><span class="line">        int left=0,right=0;</span><br><span class="line">        int len1 = version1.length();</span><br><span class="line">        int len2 = version2.length();</span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        char a,b;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1||j&lt;len2)&#123;</span><br><span class="line">            left=0;right=0;</span><br><span class="line">            // a=version1.charAt(i);</span><br><span class="line">            // b=version2.charAt(j);</span><br><span class="line">            <span class="keyword">while</span>(i&lt;len1)&#123;</span><br><span class="line">                a=version1.charAt(i);</span><br><span class="line">                <span class="keyword">if</span>(a==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                left=left*10+(a-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                //System.out.format(<span class="string">&quot;len1:%d %d\n&quot;</span>,i,left);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len2)&#123;</span><br><span class="line">                b=version2.charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(b==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                right=right*10+(b-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                //System.out.format(<span class="string">&quot;len2:%d %d\n&quot;</span>,j,right);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            //System.out.format(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">            //System.out.format(<span class="string">&quot;%d %d\n&quot;</span>,left,right);</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">                <span class="built_in">return</span> -1;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="built_in">return</span> 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目三：有效的括号"><a href="#题目三：有效的括号" class="headerlink" title="题目三：有效的括号"></a>题目三：<a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></h2><p>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  * @Description:栈</span><br><span class="line">  * @ParamType:null</span><br><span class="line">  * @Param: null</span><br><span class="line">  * @<span class="built_in">return</span>: null </span><br><span class="line">  * @Author: panpan</span><br><span class="line">  * @Date:15/3/2023</span><br><span class="line">  */</span><br><span class="line">  public boolean isValid(String s) &#123;</span><br><span class="line">      Stack&lt;Character&gt; now = new Stack&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="string">&#x27;(&#x27;</span>==s.charAt(i)||<span class="string">&#x27;&#123;&#x27;</span>==s.charAt(i)||<span class="string">&#x27;[&#x27;</span>==s.charAt(i))&#123;</span><br><span class="line">              now.push(s.charAt(i));</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(now.size()==0)&#123;</span><br><span class="line">              <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;)&#x27;</span>==s.charAt(i))&#123;</span><br><span class="line">              <span class="keyword">if</span>(now.pop()!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                  <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;&#125;&#x27;</span>==s.charAt(i))&#123;</span><br><span class="line">              <span class="keyword">if</span>(now.pop()!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                  <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;]&#x27;</span>==s.charAt(i))&#123;</span><br><span class="line">              <span class="keyword">if</span>(now.pop()!=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                  <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> now.size()==0?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //官方答案 和栈差不多，waitIn为栈顶指针，不懂为啥快很多</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">      /*</span><br><span class="line">      * 分析得出结论这组括号肯定都是双数也就是%2等于0，还有就是前括号出现对应的后括号后必须是最近的一个前括号相对应不然就是错误格式</span><br><span class="line">      * */</span><br><span class="line">      int length = s.length();</span><br><span class="line">      <span class="keyword">if</span>(length &lt;=1 ||(length % 2) != 0)&#123;</span><br><span class="line">          <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      int i = 0;</span><br><span class="line">      char[] chars = new char[s.length()];</span><br><span class="line">      int waitIn = 0;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; length; i++)&#123;</span><br><span class="line">          char c = s.charAt(i);</span><br><span class="line">          <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">              chars[waitIn] = c;</span><br><span class="line">              waitIn++;</span><br><span class="line">              <span class="built_in">continue</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(waitIn==0) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">              <span class="keyword">if</span> (chars[waitIn-1] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[waitIn-1] == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[waitIn-1] == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              waitIn--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(waitIn != 0)&#123;</span><br><span class="line">          <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目四-环形链表"><a href="#题目四-环形链表" class="headerlink" title="题目四: 环形链表"></a>题目四: <a href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">   * @Description:hashset</span><br><span class="line">   * @ParamType:null</span><br><span class="line">   * @Param: null</span><br><span class="line">   * @<span class="built_in">return</span>: null </span><br><span class="line">   * @Author: panpan</span><br><span class="line">   * @Date:15/3/2023</span><br><span class="line">   */</span><br><span class="line">   public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">       HashSet&lt;ListNode&gt; listNodes = new HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (head!=null)&#123;</span><br><span class="line">           <span class="keyword">if</span>(!listNodes.add(head))&#123;</span><br><span class="line">               <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(head.next==null)&#123;</span><br><span class="line">               <span class="built_in">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               head=head.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   //官方答案快慢指针，有环时，快指针一定能追上慢指针,感觉时间不是n。无环时，时间为n,空间为2，慢指针速度为1,避免环时访问不到某些节点导致时间复杂</span><br><span class="line">  public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">       <span class="keyword">if</span>(head == null || head.next == null)<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       ListNode fast = head.next;</span><br><span class="line">   //    // 方式一</span><br><span class="line">   //    <span class="keyword">while</span>(slow != fast)</span><br><span class="line">   //    &#123;</span><br><span class="line">   //        slow = slow.next;</span><br><span class="line">   //        <span class="keyword">if</span>(fast.next != null)</span><br><span class="line">   //        fast = fast.next.next;</span><br><span class="line">   //      <span class="keyword">else</span></span><br><span class="line">   //        fast = fast.next;</span><br><span class="line"></span><br><span class="line">   //        <span class="keyword">if</span>(fast == null)<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">   //    &#125;<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       //方式二</span><br><span class="line">       <span class="keyword">while</span>(fast != null &amp;&amp; fast.next != null)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(slow == fast)<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">           </span><br><span class="line">       &#125;<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目5：-验证二叉搜索树"><a href="#题目5：-验证二叉搜索树" class="headerlink" title="题目5： 验证二叉搜索树"></a>题目5： <a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">     * @Description:递归函数</span><br><span class="line">     * @paramType:[TreeNode]</span><br><span class="line">     * @Param:[root]</span><br><span class="line">     * @<span class="built_in">return</span>:boolean</span><br><span class="line">     * @Author:panpan</span><br><span class="line">     * @Date:15/3/2023</span><br><span class="line">     */</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        <span class="built_in">return</span> nodeLegal(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean nodeLegal(TreeNode node,long min,long max)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==null)&#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.val&gt;=max||node.val&lt;=min) &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> nodeLegal(node.left, min, node.val)&amp;&amp;nodeLegal(node.right, node.val, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">     * @Description:中序遍历</span><br><span class="line">     * @paramType:[TreeNode]</span><br><span class="line">     * @Param:[root]</span><br><span class="line">     * @<span class="built_in">return</span>:boolean</span><br><span class="line">     * @Author:panpan</span><br><span class="line">     * @Date:15/3/2023</span><br><span class="line">     */</span><br><span class="line">    public boolean isValidBSTMid(TreeNode root) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; treeNodes = new LinkedList&lt;&gt;();</span><br><span class="line">        long min =Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (!treeNodes.isEmpty()||root!=null)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root!=null)&#123;</span><br><span class="line">                treeNodes.add(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = treeNodes.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;=min)&#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min=root.val;// 最小值也就是上一个节点</span><br><span class="line">            root=root.right;// 为null则不进入内循环，直接pop出他的根节点，本身是左节点-&gt;pop根节点-&gt;right右节点</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="题目6：字母异位词分组"><a href="#题目6：字母异位词分组" class="headerlink" title="题目6：字母异位词分组"></a>题目6：<a href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h2><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。<br>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">     * @Description:<span class="built_in">hash</span>,难点就是算key</span><br><span class="line">     * @paramType:[java.lang.String[]]</span><br><span class="line">     * @Param:[strs]</span><br><span class="line">     * @<span class="built_in">return</span>:java.util.List&lt;java.util.List&lt;java.lang.String&gt;&gt;</span><br><span class="line">     * @Author:panpan</span><br><span class="line">     * @Date:16/3/2023</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;List&lt;String&gt;&gt; groupAnagrams1(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,ArrayList&lt;String&gt;&gt; resultMap = new HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String cur : strs) &#123;</span><br><span class="line">            int[] ints = new int[26];</span><br><span class="line">            <span class="keyword">for</span> (int j = 0; j &lt; cur.length(); j++) &#123;</span><br><span class="line">                ints[cur.charAt(j)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;;</span><br><span class="line">            StringBuilder keyB = new StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (int j = 0; j &lt; 26; j++) &#123;</span><br><span class="line">                // keyB.append(ints[j]);次数少于10可以这么做,否则还是下面那么做</span><br><span class="line">                <span class="keyword">if</span>(ints[j]!=0)&#123;</span><br><span class="line">                    char n=(char)(<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">                    keyB.append(n);</span><br><span class="line">                    keyB.append(ints[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            String key=keyB.toString();</span><br><span class="line">            ArrayList&lt;String&gt; group = resultMap.getOrDefault(key, new ArrayList&lt;String&gt;());</span><br><span class="line">            group.add(cur);</span><br><span class="line">            resultMap.put(key, group);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> new ArrayList&lt;List&lt;String&gt;&gt;(resultMap.values());</span><br><span class="line">    &#125;;</span><br><span class="line">        /*</span><br><span class="line">     * @Description:另外一种找key，快排，分治，边界难点，老是找不到准确的边界</span><br><span class="line">     * @paramType:[char[], int, int]</span><br><span class="line">     * @Param:[chars, first, last]</span><br><span class="line">     * @<span class="built_in">return</span>:void</span><br><span class="line">     * @Author:panpan</span><br><span class="line">     * @Date:16/3/2023</span><br><span class="line">     */</span><br><span class="line">    public static void quickSort(char[] chars,int first,int last)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first&gt;=last)&#123;<span class="built_in">return</span>;&#125;</span><br><span class="line">        int left=first;</span><br><span class="line">        int right=last;</span><br><span class="line">       char separator=chars[left];</span><br><span class="line">       <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">           <span class="keyword">while</span> (chars[left]&lt;=separator&amp;&amp;left&lt;last)&#123;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> ((chars[right]&gt;=separator&amp;&amp;right&gt;first))&#123;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">           char tem=chars[left];</span><br><span class="line">           chars[left]=chars[right];</span><br><span class="line">           chars[right]=tem;</span><br><span class="line">       &#125;</span><br><span class="line">       chars[first]=chars[left];</span><br><span class="line">       chars[left]=separator;</span><br><span class="line">        quickSort(chars, first, left-1);</span><br><span class="line">        quickSort(chars, left+1,last);</span><br><span class="line">        <span class="built_in">return</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目七：跳跃游戏"><a href="#题目七：跳跃游戏" class="headerlink" title="题目七：跳跃游戏"></a>题目七：<a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></h2><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">   * @Description:贪心</span><br><span class="line">   * @paramType:[int[]]</span><br><span class="line">   * @Param:[nums]</span><br><span class="line">   * @<span class="built_in">return</span>:boolean</span><br><span class="line">   * @Author:panpan</span><br><span class="line">   * @Date:16/3/2023</span><br><span class="line">   */</span><br><span class="line">  public boolean canJump(int[] nums) &#123;</span><br><span class="line">      //维护最远距离</span><br><span class="line">      int farthest=nums[0];</span><br><span class="line">      <span class="keyword">for</span> (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">          //能到达这个位置，且这个位置的最远距离更远</span><br><span class="line">          <span class="keyword">if</span> (farthest&lt;j)&#123;</span><br><span class="line">              <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j+nums[j]&gt;farthest)&#123;</span><br><span class="line">              farthest=j+nums[j];</span><br><span class="line">              <span class="keyword">if</span>(farthest&gt;=nums.length)&#123;</span><br><span class="line">                  <span class="built_in">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> farthest&gt;=nums.length-1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目八：下一个排列"><a href="#题目八：下一个排列" class="headerlink" title="题目八：下一个排列"></a>题目八：<a href="https://leetcode.cn/problems/next-permutation/">下一个排列</a></h2><p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">     * @Description:泪目，总算全自主写了个速度超百分百，内存超80+的中等题了,官方答案思路差不多但是内存只超百分之20就不写了。</span><br><span class="line">     * @paramType:[int[]]</span><br><span class="line">     * @Param:[nums]</span><br><span class="line">     * @<span class="built_in">return</span>:void</span><br><span class="line">     * @Author:panpan</span><br><span class="line">     * @Date:17/3/2023</span><br><span class="line">     */</span><br><span class="line">    public  static void nextPermutation(int[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = nums.length-2; j &gt;-1; j--) &#123;</span><br><span class="line">            // 从后开始一直找小于当前最大值的数，找到后换</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[j+1])&#123;</span><br><span class="line">                //找到num[j]小于序列最大值,num[j+1]-&gt;num[length-1]是降序。</span><br><span class="line">                //找到最小的大于num[j]的数，换位置</span><br><span class="line">                <span class="keyword">for</span>(int cur=j+1;cur&lt;nums.length;cur++)&#123;</span><br><span class="line">                    int temp=0;</span><br><span class="line">                    <span class="keyword">if</span>(nums[nums.length-1+j+1-cur]&gt;nums[j])&#123;</span><br><span class="line">                        temp=nums[j];</span><br><span class="line">                        nums[j]=nums[nums.length-1+j+1-cur];</span><br><span class="line">                        nums[nums.length-1+j+1-cur]=temp;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //生成最小数排列</span><br><span class="line">                <span class="keyword">for</span> (int cur = j+1; cur&lt;nums.length-1+j+1-cur; cur++) &#123;</span><br><span class="line">                    int temp=0;</span><br><span class="line">                    temp=nums[cur];</span><br><span class="line">                    nums[cur]=nums[nums.length-1+j+1-cur];</span><br><span class="line">                    nums[nums.length-1+j+1-cur]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==0)&#123;</span><br><span class="line">                //没找到num[j]，直接反转成最小值</span><br><span class="line">                <span class="keyword">for</span> (int cur = 0; cur&lt;nums.length-1-cur; cur++) &#123;</span><br><span class="line">                    int temp=0;</span><br><span class="line">                    temp=nums[cur];</span><br><span class="line">                    nums[cur]=nums[nums.length-1-cur];</span><br><span class="line">                    nums[nums.length-1-cur]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="题目九：从前序与中序遍历序列构造二叉树"><a href="#题目九：从前序与中序遍历序列构造二叉树" class="headerlink" title="题目九：从前序与中序遍历序列构造二叉树"></a>题目九：<a href="(https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)">从前序与中序遍历序列构造二叉树</a></h2><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private HashMap&lt;Integer, Integer&gt; inorderMap;</span><br><span class="line">  /*</span><br><span class="line">   * @Description:没思路。前序:【根，[左子树]，[右子树]】，中序:【[左子树]，根，[右子树]】，递归函数返回值-根，参数【前序，中序】的队列</span><br><span class="line">   * @paramType:[int[], int[]]</span><br><span class="line">   * @Param:[preorder, inorder]</span><br><span class="line">   * @<span class="built_in">return</span>:TreeNode</span><br><span class="line">   * @Author:panpan</span><br><span class="line">   * @Date:18/3/2023</span><br><span class="line">   */</span><br><span class="line">  public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">      inorderMap = new HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">if</span>(preorder.length!=inorder.length)&#123;</span><br><span class="line">          <span class="built_in">return</span> null;</span><br><span class="line">      &#125;</span><br><span class="line">      //映射表.</span><br><span class="line">      <span class="keyword">for</span>(int i=0;i&lt;inorder.length;i++)&#123;</span><br><span class="line">          inorderMap.put(inorder[i],i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">return</span> buildRootRe(preorder, inorder, 0, preorder.length-1,0,inorder.length-1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public TreeNode buildRootRe(int[] preorder, int[] inorder, int pleft, int pright,int ileft,int iright) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pright &lt; pleft)&#123;</span><br><span class="line">          <span class="built_in">return</span> null;</span><br><span class="line">      &#125;</span><br><span class="line">      int rootVal=preorder[pleft];</span><br><span class="line">      Integer in_root = inorderMap.get(rootVal);//</span><br><span class="line">      TreeNode root = new TreeNode(rootVal);</span><br><span class="line">      int leftSize=in_root-ileft;</span><br><span class="line">      root.left= buildRootRe(preorder,inorder,pleft+1,pleft+leftSize,ileft,in_root-1);</span><br><span class="line">      root.right=buildRootRe(preorder, inorder, in_root-ileft+pleft+1, pright,in_root+1,iright);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目10：-在排序数组中查找元素的第一个和最后一个位置-https-leetcode-cn-problems-find-first-and-last-position-of-element-in-sorted-array"><a href="#题目10：-在排序数组中查找元素的第一个和最后一个位置-https-leetcode-cn-problems-find-first-and-last-position-of-element-in-sorted-array" class="headerlink" title="题目10： [在排序数组中查找元素的第一个和最后一个位置]{https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/}"></a>题目10： [在排序数组中查找元素的第一个和最后一个位置]{<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/%7D">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/}</a></h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">     * @Description:二分+递归,有点混乱，time&lt;100%，memory&lt;70%</span><br><span class="line">     * @paramType:[int[], int]</span><br><span class="line">     * @Param:[nums, target]</span><br><span class="line">     * @<span class="built_in">return</span>:int[]</span><br><span class="line">     * @Author:panpan</span><br><span class="line">     * @Date:19/3/2023</span><br><span class="line">     */</span><br><span class="line">    public static int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> searchRange(nums, target, 0, nums.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int[] searchRange(int[] nums, int target,int left,int right) &#123;</span><br><span class="line">        int length=right-left+1;</span><br><span class="line">        int mid=left+(right-left+1)/2-1;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="built_in">return</span> new int[]&#123;-1,-1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length==1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==target) &#123;</span><br><span class="line">                <span class="built_in">return</span> new int[]&#123;left,left&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">return</span>  new int[]&#123;-1,-1&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            <span class="built_in">return</span> searchRange(nums, target,left,mid-1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            <span class="built_in">return</span> searchRange(nums, target,mid+1,right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            int[] leftList = searchRange(nums, target, left, mid - 1);</span><br><span class="line">            int[] rightList = searchRange(nums, target, mid + 1, right);</span><br><span class="line">            int start=mid,end=mid;</span><br><span class="line">            <span class="keyword">if</span>(leftList[1]!=-1)&#123;</span><br><span class="line">                start=leftList[0];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rightList[0]!=-1)&#123;</span><br><span class="line">                end=rightList[1];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> new int[]&#123;start,end&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //官方答案找到最后一个target的值，<span class="literal">true</span>向左找最低值，right向右找最大值，time超100%，memory超80%。</span><br><span class="line">       public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int[] res=new int[] &#123;-1,-1&#125;;</span><br><span class="line">        res[0]=searchBorder(nums,target,<span class="literal">true</span>);</span><br><span class="line">        res[1]=searchBorder(nums,target,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    public int searchBorder(int[] nums,int target,boolean leftOrRight)&#123;</span><br><span class="line">        int mid;</span><br><span class="line">        int res=-1;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=nums.length-1;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            mid=left+(right-left+1)/2;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res=mid;</span><br><span class="line">                <span class="keyword">if</span>(leftOrRight)&#123;</span><br><span class="line">                    right=mid-1;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left=mid+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>题目11：搜索旋转排序数组<br>整数数组 nums 按升序排列，数组中的值 互不相同 。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  /*</span><br><span class="line">   * @Description:就边界问题有点麻烦，官方答案就是暴力搜索，时间复杂度是O(n)不符合题意就不写了。</span><br><span class="line">   * @paramType:[int[], int]</span><br><span class="line">   * @Param:[nums, target]</span><br><span class="line">   * @<span class="built_in">return</span>:int</span><br><span class="line">   * @Author:panpan</span><br><span class="line">   * @Date:20/3/2023</span><br><span class="line">   */</span><br><span class="line">public static int search(int[] nums, int target) &#123;</span><br><span class="line">      int left=0;</span><br><span class="line">      int right=nums.length-1;</span><br><span class="line">      <span class="keyword">while</span> (right&gt;left)&#123;</span><br><span class="line">          int mid=(left+right)/2;</span><br><span class="line">          <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">              <span class="built_in">return</span> mid;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;=nums[left])&#123;//左序列为有序序列</span><br><span class="line">              <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">                  <span class="built_in">return</span> left;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&lt;target&amp;&amp;nums[mid]&gt;target)&#123;</span><br><span class="line">                  right=mid-1;</span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  left=mid+1;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;//右序列为有序序列</span><br><span class="line">              <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">                  <span class="built_in">return</span> right;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]&gt;target&amp;&amp;nums[mid]&lt;target)&#123;</span><br><span class="line">                  left=mid+1;</span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  right=mid-1;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(right==left&amp;&amp;nums[left]==target)&#123;</span><br><span class="line">          <span class="built_in">return</span> left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">return</span> -1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目12：所有可能的路径"><a href="#题目12：所有可能的路径" class="headerlink" title="题目12：所有可能的路径"></a>题目12：<a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">所有可能的路径</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">     * @Description:dfs,深度优先，图</span><br><span class="line">     * @paramType:[java.lang.String[]]</span><br><span class="line">     * @Param:[args]</span><br><span class="line">     * @<span class="built_in">return</span>:void</span><br><span class="line">     * @Author:panpan</span><br><span class="line">     * @Date:21/3/2023</span><br><span class="line">     */</span><br><span class="line">    public static List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;();//结果集</span><br><span class="line">    public static Deque&lt;Integer&gt; stack=new ArrayDeque&lt;&gt;(); //当前遍历的路径路径</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) &#123;</span><br><span class="line">        dfsFindWay(graph, 0);</span><br><span class="line">        <span class="built_in">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void dfsFindWay(int[][] graph,int start)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==graph.length-1)&#123;</span><br><span class="line">            result.add(new ArrayList&lt;&gt;(stack));</span><br><span class="line">            <span class="built_in">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            // 看</span><br><span class="line">            <span class="keyword">for</span>(int x:graph[start])&#123;//依次进入下一个可以到达的节点，深度优先</span><br><span class="line">                stack.addLast(start);</span><br><span class="line">                dfsFindWay(graph, x);</span><br><span class="line">                stack.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //官方答案，一样dfs但是重写了抽象类，时间快了很多。</span><br><span class="line">    class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) &#123;</span><br><span class="line">    <span class="built_in">return</span> new java.util.AbstractList&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; allPaths = null;</span><br><span class="line">        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;();</span><br><span class="line">        @Override </span><br><span class="line">        public List&lt;Integer&gt; get(int i) &#123;</span><br><span class="line">            <span class="built_in">return</span> allPaths.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override </span><br><span class="line">        public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (allPaths == null) &#123;</span><br><span class="line">                allPaths = new ArrayList&lt;&gt;();</span><br><span class="line">                dfs(0);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">return</span> allPaths.size();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        private void dfs(int curr) &#123;</span><br><span class="line">            path.addLast(curr);</span><br><span class="line">            <span class="keyword">if</span> (curr == graph.length-1) allPaths.add(new ArrayList&lt;&gt;(path)); <span class="keyword">else</span>  <span class="keyword">for</span> (int v : graph[curr]) dfs(v);</span><br><span class="line">            path.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>git and ssh</title>
    <url>/2023/03/07/gitssh/</url>
    <content><![CDATA[<h1 id="配置用户名"><a href="#配置用户名" class="headerlink" title="配置用户名"></a>配置用户名</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span> </span><br></pre></td></tr></table></figure>
<h1 id="配置邮箱"><a href="#配置邮箱" class="headerlink" title="配置邮箱"></a>配置邮箱</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email` <span class="string">&quot;邮箱地址&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="git生成公钥"><a href="#git生成公钥" class="headerlink" title="git生成公钥"></a>git生成公钥</h1><p>会生成在当前目录，git bash到用户的.ssh文件夹，可命名文件名，可设置打开文件的密码.默认电脑一个公钥私钥，一个公钥只能被使用一次，建议公钥绑定github账号而非github具体的仓库，部署多个<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/managing-deploy-keys">点击这里</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;邮箱地址&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="查看git的用户名和邮箱"><a href="#查看git的用户名和邮箱" class="headerlink" title="查看git的用户名和邮箱"></a>查看git的用户名和邮箱</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<h1 id="查看git的公钥"><a href="#查看git的公钥" class="headerlink" title="查看git的公钥"></a>查看git的公钥</h1><p>存储就在用户目录下的.ssh文件夹里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><p>1.先在账户上创建repository。保证用户有权限，SSH或者http登录，推荐SSH绑定账户信息，http登录仓库，方便权限管理</p>
<p>2.a 没有.git文件的，先在本地工程一级目录下初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;# HexoBogForPanpan&quot;</span> &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">&quot;first commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:pansansui/HexoBogForPanpan.git //这是在你电脑上生成了一个origin的远程仓库，连接地址是后面的，常用命令有git remote //列出远程仓库名</span><br><span class="line">git remote show [远程仓库名] //该仓库链接的详细信息</span><br><span class="line">git remote rename old-name new-name //换名</span><br><span class="line">git push -u origin main //发布到远程仓库</span><br></pre></td></tr></table></figure>
<p>2.b 有.git文件的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:pansansui/HexoBogForPanpan.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<h1 id="git-常用命令集"><a href="#git-常用命令集" class="headerlink" title="git 常用命令集"></a>git 常用命令集</h1><p>git 常用操作练习<a href="https://learngitbranching.js.org/?locale=zh_CN">点击这里</a>，该网站常用命令show solution，reset，levels<br>删除当前项目的git关联<br><code>find . -name &quot;.git&quot; | xargs rm -rf</code><br>初始化<br><code>git init</code><br>查看追踪文件状态<br><code>git status</code><br>取消文件追踪<br><code>git reset HEAD [文件路径]</code><br>添加文件追踪<br><code>git add [文件]</code><br>提交<br> <code>git commit -m [本次更新的消息提示]</code><br>创建切换分支<br><code>git branch bugFix;git checkout bugFix</code><br>或者<br><code>git checkout -b bugFix</code><br>合并当前分支与目标<br><code>git merge [目标分支]</code><br><img src=/images/merge.png width="30%" alt="未找到merge流程图片" ><br><code>git rebase [目标分支]</code></p>
<p>对最近一次提交的信息修改<br><code>git commit --amend</code></p>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello pansansui</title>
    <url>/2021/06/22/hello-world/</url>
    <content><![CDATA[<p>Welcome ! This is my first blog for review my Java knowledge . Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a><br><br><span id="more"></span></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
